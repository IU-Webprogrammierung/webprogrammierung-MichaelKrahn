<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globe & Clouds Testbed</title>
    <style>
        /* --- CORE STYLES --- */
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Playfair Display', serif;
            background-color: #e0e0e0;
            overflow: hidden; /* Hide default scrollbar, we use the .scroller div */
        }

        /* --- SNAP SCROLL CONTAINER --- */
        .scroller {
            height: 100vh;
            width: 100%;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            scroll-behavior: smooth;
            position: relative;
            z-index: 10;
        }

        /* --- SECTIONS --- */
        section {
            height: 100vh;
            width: 100%;
            scroll-snap-align: start;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            /*pointer-events: none; /* Click-through to 3D */
        }

        section * { pointer-events: auto; } /* Re-enable clicks on buttons */

        /* --- TYPOGRAPHY --- */
        h1 {
            font-size: 10vw; /* Responsive huge text */
            color: #1a1a1a;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: -2px;
            text-align: center;
        }

        h2 { font-size: 3rem; margin-bottom: 20px; color: #1a1a1a; }
        p { font-family: 'Inter', sans-serif; font-size: 1.1rem; max-width: 400px; line-height: 1.6; color: #444; }

        /* --- 3D CANVAS --- */
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* --- NAV --- */
        .nav-fixed {
            position: fixed; top: 0; left: 0; width: 100%;
            padding: 30px 50px;
            display: flex; justify-content: space-between;
            z-index: 100;
            pointer-events: none;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Inter:wght@400&display=swap" rel="stylesheet">
</head>
<body>

    <div class="nav-fixed">
        <img src="assets/Logo.png" alt="logo" width="90" height="66">
    </div>

    <div id="canvas-container"></div>

    <div class="scroller">
        
        <section id="section-1">
            <h1 class="hero-title">Heritage</h1>
        </section>

        <section id="section-2">
            <div style="position: absolute; left: 10%; bottom: 20%;">
                <h2>The World</h2>
                <p>As you scrolled, the clouds parted to reveal the globe. This is your digital clay canvas.</p>
            </div>
        </section>

        <section id="section-3">
             <div style="position: absolute; right: 10%; top: 30%; text-align: right;">
                <h2>Locations</h2>
                <p>We are active in 3 key regions.</p>
             </div>
        </section>
        
        <section id="section-4"><h1>END</h1></section>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <script>
        // --- CONFIG ---
        const config = {
            bg: 0xe0e0e0,
            globeColor: 0xffffff,
            cloudColor: 0xffffff
        };

        // --- 1. SETUP SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(config.bg);
        scene.fog = new THREE.Fog(config.bg, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- 2. LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; // Better shadow quality
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- 3. OBJECTS ---

        // A. THE GLOBE
        // We start scale at 0 so it's hidden in Section 1
        const globeGeo = new THREE.SphereGeometry(3.5, 64, 64);
        const globeMat = new THREE.MeshStandardMaterial({ 
            color: config.globeColor, 
            roughness: 0.6 
        });
        const globe = new THREE.Mesh(globeGeo, globeMat);
        globe.scale.set(0, 0, 0); // START INVISIBLE
        globe.castShadow = true;
        globe.receiveShadow = true;
        scene.add(globe);

        // B. CLOUDS
        const cloudGroup = new THREE.Group();
        const cloudGeo = new THREE.SphereGeometry(1.0, 32, 32);
        const cloudMat = new THREE.MeshStandardMaterial({ 
            color: config.cloudColor, 
            roughness: 1.0,
            transparent: true,
            opacity: 0.9,
            metalness: 0.0,
            transparent: true,
            depthWrite: false
        });

        // Create clouds with ORBIT params (angle + radius + height + z squash)
        const clouds = [];
        for (let i = 0; i < 12; i++) {
        const cloud = new THREE.Mesh(cloudGeo, cloudMat);

        // Orbit parameters
        const radius = 7 + Math.random() * 2.0;          // distance from globe center
        const angle  = Math.random() * Math.PI * 2;      // starting angle
        const yOff   = (Math.random() - 0.5) * 2.2;      // vertical offset
        const zFlat  = 0.55 + Math.random() * 0.25;      // flatten the ring in Z for perspective

        cloud.userData.orbit = { radius, angle, yOff, zFlat };
        cloud.userData.speed = 0.5 + Math.random(); // or any range you like

        // random scale for variety
        const s = 0.7 + Math.random() * 0.9;
        cloud.scale.set(s, s * 0.65, s);

        clouds.push(cloud);
        cloudGroup.add(cloud);
        }

        scene.add(cloudGroup);

        cloudGroup.position.set(0, 0, 6.5);
        cloudGroup.rotation.set(0.15, 0, 0); // slight tilt looks more natural

        const orbitCtrl = {
            spin: 0.0,     // how much the ring has rotated around Y overall
            spread: 0.2,   // 0 = tight curtain, 1 = fully around globe
            offsetZ: 6.5,  // curtain distance
            tilt: 0.15     // ring tilt
        };

        // --- 4. ANIMATION SEQUENCE ---
        gsap.registerPlugin(ScrollTrigger);

        // We create a timeline mapped to the scrolling of the .scroller container
        const scrollerEl = document.querySelector(".scroller");

        const tl = gsap.timeline({
        scrollTrigger: {
            trigger: scrollerEl,
            scroller: scrollerEl,
            start: 0,
            end: () => scrollerEl.scrollHeight - scrollerEl.clientHeight,
            scrub: 1,
            invalidateOnRefresh: true
        }
        });

        // --- STEP 1: HERO -> SECTION 2 (The Reveal) ---
        // This happens while scrolling from Section 1 to Section 2.
        
        // 3. CLOUDS: Move OUTSIDE (The "Parting" effect)
        // We move the group closer to camera (Z) and spread them (Scale) 
        // effectively making them fly past the viewer or to the edges.
        tl.to(".hero-title", { opacity: 0, filter: "blur(20px)", duration: 1 }, 0);

        // Reveal globe smoothly
        tl.to(globe.scale, { x: 1, y: 1, z: 1, ease: "power2.out", duration: 2 }, 0);

        // Pull camera slightly in (helps the “zoom-out reveal” feeling)
        tl.to(camera.position, { z: 14, duration: 2 }, 0);

        // Clouds: from curtain -> orbiting ring
        tl.to(orbitCtrl, { spread: 1, duration: 2, ease: "power2.out" }, 0);
        tl.to(orbitCtrl, { offsetZ: 0.0, duration: 2, ease: "power2.out" }, 0); // bring ring to globe

        // Add slow orbit rotation over the scroll range
        tl.to(orbitCtrl, { spin: 1.2, duration: 4, ease: "none" }, 0);

        // Keep clouds visible (no fade to 0). If you want slight fade:
        tl.to(cloudMat, { opacity: 0.65, duration: 2 }, 0.3);


        // --- STEP 2: SECTION 2 -> SECTION 3 (Interaction) ---
        // Rotate the globe and zoom camera
        tl.to(globe.rotation, { y: 2.5, duration: 2 }, 2);
        tl.to(camera.position, { z: 12, duration: 2 }, 2);
        tl.to(orbitCtrl, { spin: 2.4, duration: 2, ease: "none" }, 2);

        // --- 5. RENDER LOOP ---
        function animate() {
            
            requestAnimationFrame(animate);

            // optional idle globe rotation (keep small so scroll rotation still matters)
            globe.rotation.y += 0.001;

            // apply ring transforms
            cloudGroup.position.z = orbitCtrl.offsetZ;
            cloudGroup.rotation.x = orbitCtrl.tilt;
            cloudGroup.rotation.y = orbitCtrl.spin;

            // compute each cloud's orbital position
            clouds.forEach(c => {
                const o = c.userData.orbit;

                // spread: tighten at start, widen to full orbit
                // start radius smaller and move toward orbit radius
                const r = THREE.MathUtils.lerp(1.8, o.radius, orbitCtrl.spread);

                // angle advances a little for wobble/variation + global spin
                // keep some per-cloud motion even when scrubbed
                const sp = c.userData.speed ?? 1.0;
                o.angle += 0.002 * sp;

                const a = o.angle;

                c.position.x = Math.cos(a) * r;
                c.position.z = Math.sin(a) * r * o.zFlat;  // flattened ring depth
                c.position.y = THREE.MathUtils.lerp(0, o.yOff, orbitCtrl.spread);

                // subtle tumbling
                c.rotation.x += c.userData.speed * 0.004;
                c.rotation.y += c.userData.speed * 0.006;
            });
            renderer.render(scene, camera);
        }
        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        requestAnimationFrame(() => ScrollTrigger.refresh());

    </script>
</body>
</html>